package identity

import (
	"crypto/rand"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/crypto/curve25519"
)

const (
	// KeySize is the size of X25519 keys in bytes (256 bits).
	KeySize = 32

	// keyFileName is the name of the file storing the private key.
	keyFileName = "agent_key"

	// pubKeyFileName is the name of the file storing the public key.
	pubKeyFileName = "agent_key.pub"
)

var (
	// ErrInvalidKeyLength is returned when a key has incorrect length.
	ErrInvalidKeyLength = errors.New("invalid key length: expected 32 bytes")

	// ErrInvalidKeyHex is returned when a hex-encoded key is malformed.
	ErrInvalidKeyHex = errors.New("invalid hex string for key")

	// ErrZeroKey is returned when a key is all zeros.
	ErrZeroKey = errors.New("key is zero (uninitialized)")

	// ZeroKey represents an uninitialized key.
	ZeroKey = [KeySize]byte{}
)

// Keypair represents an X25519 key pair for end-to-end encryption.
// The private key is used for ECDH key exchange, and the public key
// is distributed via NodeInfo advertisements.
type Keypair struct {
	PrivateKey [KeySize]byte
	PublicKey  [KeySize]byte
}

// NewKeypair generates a new random X25519 keypair.
func NewKeypair() (*Keypair, error) {
	var privateKey [KeySize]byte

	if _, err := io.ReadFull(rand.Reader, privateKey[:]); err != nil {
		return nil, fmt.Errorf("failed to generate private key: %w", err)
	}

	// Clamp the private key per X25519 spec
	privateKey[0] &= 248
	privateKey[31] &= 127
	privateKey[31] |= 64

	// Compute public key from private key
	var publicKey [KeySize]byte
	curve25519.ScalarBaseMult(&publicKey, &privateKey)

	return &Keypair{
		PrivateKey: privateKey,
		PublicKey:  publicKey,
	}, nil
}

// DerivePublicKey derives the public key from a private key.
// The private key should already be clamped (as generated by NewKeypair).
func DerivePublicKey(privateKey [KeySize]byte) [KeySize]byte {
	var publicKey [KeySize]byte
	curve25519.ScalarBaseMult(&publicKey, &privateKey)
	return publicKey
}

// ParseKey parses a key from a hex string.
func ParseKey(s string) ([KeySize]byte, error) {
	var key [KeySize]byte

	// Remove any whitespace and 0x prefix
	s = strings.TrimSpace(s)
	s = strings.TrimPrefix(s, "0x")
	s = strings.TrimPrefix(s, "0X")

	if len(s) != KeySize*2 {
		return key, fmt.Errorf("%w: got %d hex chars, expected %d", ErrInvalidKeyHex, len(s), KeySize*2)
	}

	bytes, err := hex.DecodeString(s)
	if err != nil {
		return key, fmt.Errorf("%w: %v", ErrInvalidKeyHex, err)
	}

	copy(key[:], bytes)
	return key, nil
}

// KeyToString returns the hex representation of a key.
func KeyToString(key [KeySize]byte) string {
	return hex.EncodeToString(key[:])
}

// IsZeroKey returns true if the key is all zeros.
func IsZeroKey(key [KeySize]byte) bool {
	return key == ZeroKey
}

// Store persists the keypair to the specified data directory.
// The private key is stored with 0600 permissions (owner read/write only).
// The public key is stored with 0644 permissions (world readable).
func (kp *Keypair) Store(dataDir string) error {
	if IsZeroKey(kp.PrivateKey) {
		return errors.New("cannot store zero private key")
	}
	if IsZeroKey(kp.PublicKey) {
		return errors.New("cannot store zero public key")
	}

	// Ensure directory exists
	if err := os.MkdirAll(dataDir, 0700); err != nil {
		return fmt.Errorf("failed to create data directory: %w", err)
	}

	// Store private key atomically with restricted permissions
	privPath := filepath.Join(dataDir, keyFileName)
	privTempPath := privPath + ".tmp"
	if err := os.WriteFile(privTempPath, []byte(KeyToString(kp.PrivateKey)+"\n"), 0600); err != nil {
		return fmt.Errorf("failed to write private key: %w", err)
	}
	if err := os.Rename(privTempPath, privPath); err != nil {
		os.Remove(privTempPath)
		return fmt.Errorf("failed to persist private key: %w", err)
	}

	// Store public key atomically with readable permissions
	pubPath := filepath.Join(dataDir, pubKeyFileName)
	pubTempPath := pubPath + ".tmp"
	if err := os.WriteFile(pubTempPath, []byte(KeyToString(kp.PublicKey)+"\n"), 0644); err != nil {
		// Try to clean up private key if public key write fails
		os.Remove(privPath)
		return fmt.Errorf("failed to write public key: %w", err)
	}
	if err := os.Rename(pubTempPath, pubPath); err != nil {
		os.Remove(pubTempPath)
		os.Remove(privPath)
		return fmt.Errorf("failed to persist public key: %w", err)
	}

	return nil
}

// LoadKeypair reads a keypair from the specified data directory.
func LoadKeypair(dataDir string) (*Keypair, error) {
	// Load private key
	privPath := filepath.Join(dataDir, keyFileName)
	privData, err := os.ReadFile(privPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("keypair not found at %s", dataDir)
		}
		return nil, fmt.Errorf("failed to read private key: %w", err)
	}

	privateKey, err := ParseKey(strings.TrimSpace(string(privData)))
	if err != nil {
		return nil, fmt.Errorf("failed to parse private key: %w", err)
	}

	// Load public key
	pubPath := filepath.Join(dataDir, pubKeyFileName)
	pubData, err := os.ReadFile(pubPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("public key not found at %s", pubPath)
		}
		return nil, fmt.Errorf("failed to read public key: %w", err)
	}

	publicKey, err := ParseKey(strings.TrimSpace(string(pubData)))
	if err != nil {
		return nil, fmt.Errorf("failed to parse public key: %w", err)
	}

	// Verify the public key matches the private key
	var derivedPub [KeySize]byte
	curve25519.ScalarBaseMult(&derivedPub, &privateKey)
	if derivedPub != publicKey {
		return nil, errors.New("public key does not match private key")
	}

	return &Keypair{
		PrivateKey: privateKey,
		PublicKey:  publicKey,
	}, nil
}

// LoadOrCreateKeypair loads an existing keypair from the data directory,
// or creates and persists a new one if none exists.
// Returns the keypair, a boolean indicating if it was newly created, and any error.
func LoadOrCreateKeypair(dataDir string) (*Keypair, bool, error) {
	kp, err := LoadKeypair(dataDir)
	if err == nil {
		return kp, false, nil // Loaded existing keypair
	}

	// Check if it's a "not found" error
	if !strings.Contains(err.Error(), "not found") {
		return nil, false, err // Some other error
	}

	// Generate new keypair
	kp, err = NewKeypair()
	if err != nil {
		return nil, false, err
	}

	// Persist it
	if err := kp.Store(dataDir); err != nil {
		return nil, false, err
	}

	return kp, true, nil // Created new keypair
}

// KeypairFromConfig creates a Keypair from config-provided hex values.
// privateKeyHex is required, publicKeyHex is optional (derived if empty).
// If publicKeyHex is provided, it must match the derivation from privateKeyHex.
// Returns the keypair and any error.
func KeypairFromConfig(privateKeyHex, publicKeyHex string) (*Keypair, error) {
	if privateKeyHex == "" {
		return nil, errors.New("private key is required")
	}

	// Parse private key
	privateKey, err := ParseKey(privateKeyHex)
	if err != nil {
		return nil, fmt.Errorf("invalid private key: %w", err)
	}

	// Derive public key from private
	derivedPublic := DerivePublicKey(privateKey)

	// If public key provided, validate it matches derivation
	if publicKeyHex != "" {
		providedPublic, err := ParseKey(publicKeyHex)
		if err != nil {
			return nil, fmt.Errorf("invalid public key: %w", err)
		}
		if providedPublic != derivedPublic {
			return nil, errors.New("public key does not match derivation from private key")
		}
	}

	return &Keypair{
		PrivateKey: privateKey,
		PublicKey:  derivedPublic,
	}, nil
}

// KeypairExists checks if a keypair exists in the data directory.
func KeypairExists(dataDir string) bool {
	privPath := filepath.Join(dataDir, keyFileName)
	pubPath := filepath.Join(dataDir, pubKeyFileName)

	_, privErr := os.Stat(privPath)
	_, pubErr := os.Stat(pubPath)

	return privErr == nil && pubErr == nil
}

// Zero zeroes out the private key to prevent it from lingering in memory.
// This should be called when the keypair is no longer needed.
func (kp *Keypair) Zero() {
	for i := range kp.PrivateKey {
		kp.PrivateKey[i] = 0
	}
}

// PublicKeyString returns the hex representation of the public key.
func (kp *Keypair) PublicKeyString() string {
	return KeyToString(kp.PublicKey)
}

// PublicKeyShortString returns a shortened hex representation (first 16 chars).
func (kp *Keypair) PublicKeyShortString() string {
	return hex.EncodeToString(kp.PublicKey[:8])
}
